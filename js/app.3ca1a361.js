(function(){var e={9235:function(e,o,t){"use strict";var i=t(9242),n=t(3396);function s(e,o,t,i,s,r){const d=(0,n.up)("TronBox");return(0,n.wg)(),(0,n.j4)(d,{"canvas-id":"grid"})}var r=t(7139);const d=e=>((0,n.dD)("data-v-912045a4"),e=e(),(0,n.Cn)(),e),a={class:"grid-box"},l=d((()=>(0,n._)("div",{class:"header"},[(0,n._)("h1",null,"Tron Battle Bots")],-1))),c={class:"flex-box-row"},h={class:"flex-box-row no-gap"},u=d((()=>(0,n._)("p",{class:"tip"}," Press 'a' or 'b' on the keyboard to place a bot at your mouse position! ",-1))),p=["id"],v={class:"winner-box"},g=d((()=>(0,n._)("h2",null,"Points:",-1))),f={key:0},m={class:"editor"},P={class:"controls"},y={class:"multi-control"},b={class:"multi-control"},x=d((()=>(0,n._)("h6",null,"BOT A:",-1))),w=d((()=>(0,n._)("h6",null,"BOT B:",-1)));function M(e,o,t,s,d,M){return(0,n.wg)(),(0,n.iD)("div",a,[l,(0,n._)("div",c,[(0,n._)("div",h,[(0,n._)("div",null,[u,(0,n._)("canvas",{id:t.canvasId,ref:"canvas",width:"500",class:"canvas-style",height:"500",onMousemove:o[0]||(o[0]=(...e)=>M.mouseMove&&M.mouseMove(...e)),onMouseenter:o[1]||(o[1]=(...e)=>M.canvasMouseEnter&&M.canvasMouseEnter(...e)),onMouseleave:o[2]||(o[2]=(...e)=>M.canvasMouseLeave&&M.canvasMouseLeave(...e))},null,40,p)]),(0,n._)("div",v,[g,M.showWinnerText?((0,n.wg)(),(0,n.iD)("ol",f,[((0,n.wg)(!0),(0,n.iD)(n.HY,null,(0,n.Ko)(e.engine.winners,(e=>((0,n.wg)(),(0,n.iD)("li",{key:e.id},[(0,n._)("b",{style:(0,r.j5)(`color: ${e.color}`)},"TRAIL ["+(0,r.zw)(e.id)+"]",5),(0,n.Uk)(" - POINTS: "+(0,r.zw)(e.points),1)])))),128))])):(0,n.kq)("",!0)])]),(0,n._)("div",m,[(0,n._)("div",P,[(0,n._)("div",y,[(0,n._)("button",{class:"btn btn-dark",onClick:o[3]||(o[3]=o=>M.addBot(e.botA))},"ADD [A]"),(0,n.wy)((0,n._)("input",{id:"colorPickerA","onUpdate:modelValue":o[4]||(o[4]=o=>e.botA.color=o),type:"color"},null,512),[[i.nr,e.botA.color]]),(0,n.wy)((0,n._)("input",{"onUpdate:modelValue":o[5]||(o[5]=o=>e.botA.posTxt=o),type:"text",class:"pos-input"},null,512),[[i.nr,e.botA.posTxt]])]),(0,n._)("div",b,[(0,n._)("button",{class:"btn btn-dark",onClick:o[6]||(o[6]=o=>M.addBot(e.botB))},"ADD [B]"),(0,n.wy)((0,n._)("input",{id:"colorPickerB","onUpdate:modelValue":o[7]||(o[7]=o=>e.botB.color=o),type:"color"},null,512),[[i.nr,e.botB.color]]),(0,n.wy)((0,n._)("input",{"onUpdate:modelValue":o[8]||(o[8]=o=>e.botB.posTxt=o),type:"text",class:"pos-input"},null,512),[[i.nr,e.botB.posTxt]])]),(0,n._)("button",{class:"btn btn-dark",onClick:o[9]||(o[9]=(...e)=>M.clear&&M.clear(...e))},"CLEAR"),(0,n._)("button",{class:"btn btn-dark",onClick:o[10]||(o[10]=(...e)=>M.randomizeBots&&M.randomizeBots(...e))},"RANDOM"),(0,n._)("button",{class:"btn btn-dark",onClick:o[11]||(o[11]=(...e)=>M.togglePause&&M.togglePause(...e))},(0,r.zw)(M.pauseBtnText),1),(0,n._)("button",{class:"btn btn-dark",onClick:o[12]||(o[12]=(...e)=>M.step&&M.step(...e))},"STEP"),(0,n._)("button",{class:"btn btn-dark",onClick:o[13]||(o[13]=(...e)=>M.benchmark&&M.benchmark(...e))},"BENCHMARK")]),(0,n._)("div",null,[x,(0,n.wy)((0,n._)("textarea",{"onUpdate:modelValue":o[14]||(o[14]=o=>e.botA.js=o),class:"code-area",style:(0,r.j5)(`border-color: ${e.botA.color}`)},null,4),[[i.nr,e.botA.js]])]),(0,n._)("div",null,[w,(0,n.wy)((0,n._)("textarea",{"onUpdate:modelValue":o[15]||(o[15]=o=>e.botB.js=o),class:"code-area",style:(0,r.j5)(`border-color: ${e.botB.color}`)},null,4),[[i.nr,e.botB.js]])])])])])}t(2262),t(4506);var T=t(9782);class I{constructor(){}static isOccupied(e,o){if(e&&e.length&&e[0].length&&!(o.x>=e.length||o.x<0||o.y<0||!e[o.x]||o.y>=e[o.x].length))return void 0!=e[o.x][o.y]}static flatten(e){return e.map(((e,o)=>e.map(((e,t)=>({position:new T.Point(o,t),id:e}))))).flatMap((e=>e))}static setOwner(e,o,t){e&&e.length&&e[0].length&&(o.x>=e.length||o.x<0||o.y<0||!e[o.x]||o.y>=e[o.x].length||(e[o.x][o.y]=t))}static getRandomValidPos(e){var o=I.flatten(e).filter((o=>!I.isOccupied(e,o.position)));if(!(o.length<1)){var t=o[Math.floor(Math.random()*o.length)].gridPosition;return t}console.log("No open spots to spawn in a tron bike!")}static copy(e){let o=e.map((e=>[...e]));return o}}const C=t(5445);class A{constructor(e){this.canvasId=e,this.reset()}reset(){C.project?.activeLayer?.removeChildren(),C.projects.forEach((e=>{e.remove()})),C.setup(this.canvasId),this.grid=void 0,this.trailStuff={},this.colors=["#A72334","#FC7A43","#ECCF39","#6FAF60","#02654B","#188DBF","#22379B","#7209b7","#f72585"],this.colorIndex=0}convertMousePosToGridPos(e){if(this.grid){var o=this.grid.map(((e,o)=>e.map(((e,t)=>(e.gridPosition=new T.Point(o,t),e))))).flatMap((e=>e)).find((o=>o.hitTest(new T.Point(e.x,e.y))));return o?o.gridPosition:void 0}}render(e){let o=e.grid,t=e.trails;if(!o.expired){if(void 0===this.grid){var i=50;this.grid=o.map(((e,o)=>e.map(((e,t)=>{var n=new C.Path.Rectangle(new C.Point(o*i,t*i),new C.Size(i,i));return n.strokeColor="#444",n.fillColor="#090909",n}))))}for(let e of t){this.trailStuff[e.id]||(this.trailStuff[e.id]={});let o=this.trailStuff[e.id];for(let n of e.tail){let o=this.grid[n.x][n.y];o.fillColor=e.color,o.strokeWidth=1,o.shadowColor="#000",o.shadowBlur=10}o.wireframe||(o.wireframe=new C.Path([...e.tail,e.head].map((e=>this.grid[e.x][e.y].position))),o.wireframe.strokeColor=new C.Color(0,0,0,.25),o.wireframe.strokeWidth=5),o.wireframe.segments.at(-1).x!=e.head.x&&o.wireframe.segments.at(-1).y!=e.head.y&&o.wireframe.add(this.grid[e.head.x][e.head.y].position);let t=this.grid[e.head.x][e.head.y];t.strokeColor=e.color,t.fillColor=e.color,t.strokeWidth=10,t.shadowColor="#000",t.shadowBlur=20,t.bringToFront();let i=o.headIndicator;if(i||(i=new C.Path.Circle(t.position,15),i.fillColor=e.color,i.strokeColor="#FFF",i.strokeWidth=10,o.headIndicator=i),!e.alive&&!o.deadSymbolHead){i.remove();let e=new C.Path.RegularPolygon(t.position,3,25);e.fillColor="#000",e.position=t.position,o.deadSymbolHead=e}o.wireframe.bringToFront(),i.bringToFront(),i.position=t.position,o.deadSymbolHead?.bringToFront()}}}}class B{constructor(e=0,o=0){this.x=+e,this.y=+o}add(e){return new B(this.x+e.x,this.y+e.y)}}const O={colors:["#A72334","#FC7A43","#ECCF39","#6FAF60","#02654B","#188DBF","#22379B","#7209b7","#f72585"],MoveDirection:{UP:new B(0,-1),DOWN:new B(0,1),LEFT:new B(-1,0),RIGHT:new B(1,0)}};class k{constructor(e,o,t,i){this.head=e,this.tail=[],this.color=o,this.id=t,this.getMove=i,this.alive=!0,this.state={}}applyMove(e){this.tail.push(this.head),this.head=e}}class S{static getRandomColorHex(){const e=(e,o)=>Math.floor(Math.random()*(o-e+1))+e;function o(e,o,t){t/=100;const i=o*Math.min(t,1-t)/100,n=o=>{const n=(o+e/30)%12,s=t-i*Math.max(Math.min(n-3,9-n,1),-1);return Math.round(255*s).toString(16).padStart(2,"0")};return`#${n(0)}${n(8)}${n(4)}`}var t=e(0,360),i=e(50,100),n=e(30,70);return o(t,i,n)}}class _{static isValidMoveDir(e,o,t,i){if(!t||void 0==t.x||void 0==t.y)return[!1,["Error - moveDir is not a valid Point object. Killing trail. moveDir supplied:",t]];if(!Object.keys(Constants.MoveDirection).map((e=>Constants.MoveDirection[e])).some((e=>t.x==e.x&&t.y==e.y)))return[!1,["Invalid move supplied! Killing trail. Move supplied: ",t]];let n=new B(o.head.x+t.x,o.head.y+t.y);if(n.x<0||n.x>=e.length||n.y<0||n.y>=e[n.x].length)return[!1,[`%cTRAIL [${o.id}] %ctried to escape the grid! They failed...`,"color: "+o.color,"color: auto"]];if(I.isOccupied(e,n)){var s=e[n.x][n.y],r=i.find((e=>e.id==s));return[!1,[`%cTRAIL [${o.id}] %chit %cTRAIL [${r.id}]`,"color: "+o.color,"color: auto","color: "+r.color]]}return[!0]}}class R{constructor(){window.Constants=O,window.Point=T.Point,window.Grid=I,this.reset()}log(){this.debug&&console.log(...arguments)}reset(){this.debug=!0,this.expired=!1,this.path=null,this.point={x:0,y:0},this.grid=void 0,this.trails=[],this.gridWidth=10,this.colorIndex=0,this.winners=[],this.createGrid()}get allBotsDead(){return this.trails.length&&this.trails.every((e=>!e.alive))}createGrid(){this.grid=[];for(var e=0;e<this.gridWidth;e++){this.grid[e]=[];for(var o=0;o<this.gridWidth;o++)this.grid[e].push(void 0)}}parseRawJsIntoGetMoveFunction(e){let o=new Function("return getMove; "+e)();return o}addTrail(e,o,t,i){if(this.expired)return void this.log("Engine has expired - please reset before addinga new bot.");if(i=i||I.getRandomValidPos(this.grid),!i)return;t=t||S.getRandomColorHex();let n=0,s=o;while(this.trails.some((e=>e.id==o)))o=s+n++;var r=new k(i,t,o,e);this.trails.push(r),this.setGridCellOwner(r)}setGridCellOwner(e){I.setOwner(this.grid,e.head,e.id)}determineWinners(){if(this.trails.length<1)return;var e=I.flatten(this.grid).filter((e=>I.isOccupied(this.grid,e.position))).reduce(((e,o)=>(e.has(o.id)||e.set(o.id,{points:0,trail:this.trails.find((e=>e.id==o.id))}),e.get(o.id).points+=1,e)),new Map);if(e.size<1)return void this.log("No winners??");let o=Array.from(e.values()).sort(((e,o)=>o.points-e.points));for(var t of(this.log("\n\n\n"),this.log("#############################"),this.log("##         WINNERS         ##"),this.log("#############################"),o)){let e=t.trail;e.points=t.points,this.log(`%c > %cTRAIL [${e.id}] %c POINTS: ${e.points}`,"color: auto",`color: ${e.color};`,"color: auto"),this.winners.push(e)}this.expired=!0}iterateTrails(){for(let i of this.trails.filter((e=>e.alive))){try{var e=i.getMove(this.grid,i.head,i.id,this.trails.map((e=>({...e,getMove:void 0,state:void 0}))),i.state)}catch(t){this.log("Error executing script: ",t,i.getMove)}let[o,n]=_.isValidMoveDir(this.grid,i,e,this.trails);if(!o){i.alive=!1,this.log(...n);continue}let s=i.head.add(e);i.nextMovePos=s}let o=this.trails.filter((e=>e.alive));for(let i=0;i<o.length;i++){let e=o[i];for(let n=i+1;n<o.length;n++){let t=o[n];e.nextMovePos.x==t.nextMovePos.x&&e.nextMovePos.y==t.nextMovePos.y&&(e.alive=!1,t.alive=!1,this.log(`TRAIL [${e.id}] and TRAIL [${t.id}] tried to occupy the same space: (${e.nextMovePos.x},${e.nextMovePos.y})`))}let t=e.nextMovePos;e.nextMovePos=void 0,e.alive&&(e.applyMove(t),this.setGridCellOwner(e))}}step(){this.expired||this.allBotsDead||this.iterateTrails(),!this.expired&&this.allBotsDead&&this.determineWinners()}}var F="// Clockwise bot - Example:\nfunction getMove(grid, headPos, myTrailId, trails, state) {\n  var dir = Constants.MoveDirection;\n  if (isValidMove(grid, headPos, dir.RIGHT)) return dir.RIGHT;\n  if (isValidMove(grid, headPos, dir.DOWN)) return dir.DOWN;\n  if (isValidMove(grid, headPos, dir.LEFT)) return dir.LEFT;\n  if (isValidMove(grid, headPos, dir.UP)) return dir.UP;\n  return dir.RIGHT;\n}\n\nfunction isValidMove(grid, headPos, move) {\n  var nextPos = new Point(headPos.x + move.x, headPos.y + move.y);\n  var isOccupied = Grid.isOccupied(grid, nextPos);\n  return isOccupied == false; // this works because isOccupied is \n  //    exactly false if the square is free, \n  //    true if occupied, \n  //    undefined if out of bounds\n}",D='// minimax bot - ASW:\nfunction getMove(grid, headPos, myTrailId, trails, state) {\n  var dir = Constants.MoveDirection;\n  let opponent = trails.find(x => x.id != myTrailId);\n  let bestScore = calculateScore(grid, headPos);\n  let validMoves = getAdjMoves(grid, headPos);\n  let move = validMoves[0] || dir.UP;\n\n  for (var validMove of validMoves) {\n    //console.log("tesing move:", validMove, " head pos", headPos, " opp: ", opponent.head);\n    let gridCopy = Grid.copy(grid); //Grid.setOwner(gridCopy, headPos, myTrailId);\n\n    Grid.setOwner(gridCopy, headPos.add(validMove), myTrailId);\n\n    if (distance(headPos.add(validMove), opponent.head) <= 1.1) {\n      //console.log("********************* Alert!");\n      continue;\n    }\n\n    let score = minimax(gridCopy, headPos.add(validMove), myTrailId, opponent.head, opponent.id, 3, trails, true);\n\n    if (score > bestScore) {\n      //console.log("picking move ", validMove, " for score: ", score);\n      bestScore = score;\n      move = validMove;\n    }\n  } //console.log("Returning move:", move);\n  //console.log("======================");\n\n\n  return move;\n  if (isValidMove(grid, headPos, dir.RIGHT)) return dir.RIGHT;\n  if (isValidMove(grid, headPos, dir.DOWN)) return dir.DOWN;\n  if (isValidMove(grid, headPos, dir.LEFT)) return dir.LEFT;\n  if (isValidMove(grid, headPos, dir.UP)) return dir.UP;\n  return dir.RIGHT;\n}\n\nfunction distance(pos1, pos2) {\n  let dis = Math.sqrt(Math.pow(pos2.x - pos1.x, 2) + Math.pow(pos2.y - pos1.y, 2));\n  return dis;\n}\n\nfunction minimax(grid, headPos, myId, opponentHeadPos, opponentId, depth, trails, maximizing = true) {\n  // TODO: Check for winner first?\n  if (maximizing) {\n    if (depth < 0) return calculateScore(grid, myId);\n    let bestScore = -Infinity; //console.log(\'.\'.repeat(2 - depth) + "[MAX] headPos: ", headPos, \' opp: \', opponentHeadPos);\n\n    let validMoves = getAdjMoves(grid, headPos);\n\n    for (let move of validMoves) {\n      //console.log(\'.\'.repeat(2 - depth) + \'[MAX] test move\', move, " head pos ", headPos.add(move), " opponent: ", opponentHeadPos);\n      let dis = distance(headPos.add(move), opponentHeadPos);\n\n      if (dis < 1) {\n        if (calculateScore(grid, myId) <= calculateScore(grid, opponentId)) {\n          //console.log("[MAX] potential death", headPos.add(move), opponentHeadPos);\n          bestScore -= 2;\n        }\n      }\n\n      let gridCopy = Grid.copy(grid);\n      let score = minimax(gridCopy, headPos.add(move), myId, opponentHeadPos, opponentId, depth - 1, trails, false);\n      Grid.setOwner(gridCopy, headPos.add(move), myId);\n      bestScore = Math.max(score, bestScore); //console.log(\'MAX best score \', bestScore);\n    }\n\n    return bestScore;\n  } else {\n    if (depth < 0) return calculateScore(grid, myId);\n    let bestScore = Infinity; //console.log(\'.\'.repeat(2 - depth) + "[min] headPos: ", headPos, \' opp: \', opponentHeadPos);\n\n    let validMoves = getAdjMoves(grid, opponentHeadPos);\n\n    if (validMoves.length < 1) {\n      //console.log("[min] no valid moves headPos: ", headPos, " opponentHeadPos: ", opponentHeadPos);\n      return 0;\n    }\n\n    for (let move of validMoves) {\n      //console.log(\'.\'.repeat(2 - depth) + \'[min] test move\', move, " head pos ", headPos, " opp: ", opponentHeadPos.add(move));\n      let dis = distance(headPos, opponentHeadPos.add(move));\n\n      if (dis <= 1.1) {\n        // if dis == 1 then we are adj and cannot die.\n        if (calculateScore(grid, myId) >= calculateScore(grid, opponentId)) {\n          //console.log("[MIN] potential death", headPos, opponentHeadPos.add(move));\n          bestScore += 1;\n          break;\n        }\n      }\n\n      let gridCopy = Grid.copy(grid);\n      Grid.setOwner(gridCopy, opponentHeadPos.add(move), opponentId);\n      let score = minimax(gridCopy, headPos, myId, opponentHeadPos.add(move), opponentId, depth - 1, trails, true);\n      bestScore = Math.min(score, bestScore); //console.log(\'min best score \', bestScore);\n    }\n\n    return bestScore;\n  }\n}\n\nfunction calculateScore(grid, id) {\n  let score = Grid.flatten(grid).filter(x => x.id == id).length; //console.log(`[${id}] score: ${score}`);\n\n  return score;\n}\n\nfunction getAdjMoves(grid, headPos) {\n  var dir = Constants.MoveDirection;\n  let adj = [];\n  if (isValidMove(grid, headPos, dir.UP)) adj.push(dir.UP);\n  if (isValidMove(grid, headPos, dir.RIGHT)) adj.push(dir.RIGHT);\n  if (isValidMove(grid, headPos, dir.DOWN)) adj.push(dir.DOWN);\n  if (isValidMove(grid, headPos, dir.LEFT)) adj.push(dir.LEFT);\n  return adj;\n}\n\nfunction isValidMove(grid, headPos, move) {\n  var nextPos = new Point(headPos.x + move.x, headPos.y + move.y);\n  var isOccupied = Grid.isOccupied(grid, nextPos);\n  return isOccupied == false; // this works because isOccupied is \n  //    exactly false if the square is free, \n  //    true if occupied, \n  //    undefined if out of bounds\n}\n\nfunction isValidMove2(grid, headPos, move) {\n  var nextPos = new Point(headPos.x + move.x, headPos.y + move.y);\n  var isOccupied = Grid.isOccupied(grid, nextPos);\n  return isOccupied == false; // this works because isOccupied is \n  //    exactly false if the square is free, \n  //    true if occupied, \n  //    undefined if out of bounds\n}',H={name:"TronBox",props:{canvasId:{type:String,required:!0}},data:()=>({botA:{js:D,color:"#FF0000",prevColor:"#FF0000",posTxt:"2,7",id:"A"},botB:{js:F,color:"#0000FF",prevColor:"#0000FF",posTxt:"7,9",id:"B"},renderer:void 0,engine:void 0,paused:!0,mousePos:{x:0,y:0},mouseIsOnCanvas:!1,lastKeyPressed:void 0}),computed:{pauseBtnText:function(){return this.paused?"PLAY":"PAUSE"},showWinnerText:function(){return this.engine?.winners?.length>0}},mounted(){window.addEventListener("keydown",this.keyDown),window.addEventListener("keyup",this.keyUp),this.renderer=new A(this.canvasId),this.engine=new R,this.start()},methods:{convertPosTxtToPoint(e){let[o,t,i]=e.match(/(\d+),(\d+)/);return new B(t,i)},addBot(e,o){let t=this.engine.parseRawJsIntoGetMoveFunction(e.js);o=o||this.convertPosTxtToPoint(e.posTxt),this.engine.addTrail(t,e.id,e.color,o)},clear(){this.engine.reset(),this.renderer.reset()},step(){this.engine.step()},randomizeBots(){this.clear(),this.randomizeBot(this.botA),this.randomizeBot(this.botB),this.addInitialTrails()},randomizeBot(e){let o=()=>Math.floor(10*Math.random());e.posTxt=o()+","+o()},addInitialTrails(){this.addBot(this.botA),this.addBot(this.botB)},start(){this.addInitialTrails(),this.loop()},togglePause(){this.paused=!this.paused},canvasMouseEnter(){this.mouseIsOnCanvas=!0},canvasMouseLeave(){this.mouseIsOnCanvas=!1},addBotAtMousePos(e){if(this.mouseIsOnCanvas){var o=this.renderer.convertMousePosToGridPos(this.mousePos);o&&!Grid.isOccupied(this.engine.grid,o)&&this.addBot(e,o)}},keyDown(e){this.lastKeyPressed!=e.key&&(this.lastKeyPressed=e.key,"a"==e.key?this.addBotAtMousePos(this.botA):"b"==e.key&&this.addBotAtMousePos(this.botB))},keyUp(e){this.lastKeyPressed=void 0},mouseMove(e){var o=this.$refs.canvas.getBoundingClientRect();this.mousePos={x:Math.floor(e.clientX-o.left),y:Math.floor(e.clientY-o.top)}},loop(){this.paused||this.engine.step(),this.renderer.render(this.engine),setTimeout(this.loop,50)},async benchmark(){window.BENCHMARK_MAX_ITERATIONS||(window.BENCHMARK_MAX_ITERATIONS=100);let e=window.BENCHMARK_MAX_ITERATIONS,o=new Map;for(let r=1;r<=e;r++){this.randomizeBots(),this.engine.debug=!1;let t=this.botA;this.botA=this.botB,this.botB=t;while(!this.engine.expired)await new Promise((e=>{this.engine.step(),e()}));let i=this.engine.winners.filter((e=>e.points==this.engine.winners[0].points));for(let e of i)o.has(e.id)||o.set(e.id,{...e,wins:0}),1==i.length&&o.get(e.id).wins++;console.log(`Running iteration ${r}/${e}`)}console.log("================="),console.log("BENCHMARK RESULTS:");let t=o.get(this.botA.id).wins,i=o.get(this.botB.id).wins,n=(t/e*100).toFixed(1),s=(i/e*100).toFixed(1);console.log(`Bot A wins: ${t}/${e} (${n}%)`),console.log(`Bot B wins: ${i}/${e} (${s}%)`),console.log("      Ties: ",e-(t+i)),this.engine.debug=!0}}},j=t(89);const E=(0,j.Z)(H,[["render",M],["__scopeId","data-v-912045a4"]]);var G=E,$={name:"App",components:{TronBox:G}};const V=(0,j.Z)($,[["render",s]]);var L=V;t(8937);(0,i.ri)(L).mount("#app")},858:function(){},4158:function(){}},o={};function t(i){var n=o[i];if(void 0!==n)return n.exports;var s=o[i]={exports:{}};return e[i].call(s.exports,s,s.exports,t),s.exports}t.m=e,function(){var e=[];t.O=function(o,i,n,s){if(!i){var r=1/0;for(c=0;c<e.length;c++){i=e[c][0],n=e[c][1],s=e[c][2];for(var d=!0,a=0;a<i.length;a++)(!1&s||r>=s)&&Object.keys(t.O).every((function(e){return t.O[e](i[a])}))?i.splice(a--,1):(d=!1,s<r&&(r=s));if(d){e.splice(c--,1);var l=n();void 0!==l&&(o=l)}}return o}s=s||0;for(var c=e.length;c>0&&e[c-1][2]>s;c--)e[c]=e[c-1];e[c]=[i,n,s]}}(),function(){t.n=function(e){var o=e&&e.__esModule?function(){return e["default"]}:function(){return e};return t.d(o,{a:o}),o}}(),function(){t.d=function(e,o){for(var i in o)t.o(o,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:o[i]})}}(),function(){t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){t.o=function(e,o){return Object.prototype.hasOwnProperty.call(e,o)}}(),function(){t.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}}(),function(){var e={143:0};t.O.j=function(o){return 0===e[o]};var o=function(o,i){var n,s,r=i[0],d=i[1],a=i[2],l=0;if(r.some((function(o){return 0!==e[o]}))){for(n in d)t.o(d,n)&&(t.m[n]=d[n]);if(a)var c=a(t)}for(o&&o(i);l<r.length;l++)s=r[l],t.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return t.O(c)},i=self["webpackChunktronbox"]=self["webpackChunktronbox"]||[];i.forEach(o.bind(null,0)),i.push=o.bind(null,i.push.bind(i))}();var i=t.O(void 0,[998],(function(){return t(9235)}));i=t.O(i)})();
//# sourceMappingURL=app.3ca1a361.js.map